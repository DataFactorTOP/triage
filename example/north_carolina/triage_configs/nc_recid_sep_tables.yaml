config_version: 'v7'

model_comment: 'nc_recidivism: initial_test'

user_metadata:
    label_definition: 'recidivated'
    experiment_type: 'exploratory'
    description: |
      Baseline calculation
    purpose: 'baseline'
    org: 'DSaPP'
    team: 'Aequitas for Triage'
    author: 'Loren Hinkson'
    etl_date: '2019-05-29'

model_group_keys:
  - 'class_path'
  - 'parameters'
  - 'feature_names'
  - 'feature_groups'
  - 'cohort_name'
  - 'state'
  - 'label_name'
  - 'label_timespan'
  - 'training_as_of_date_frequency'
  - 'max_training_history'
  - 'label_definition'
  - 'experiment_type'
  # - 'org'
  # - 'team'
  # - 'author'
  # - 'purpose'
  # - 'etl_date'
  
random_seed: 1007
 
# TIME SPLITTING
# The time window to look at, and how to divide the window into
# train/test splits
temporal_config:
    # feature_start_time: '1975-01-01' # earliest date included in features
    feature_start_time: '2016-01-01' # earliest date included in features
    feature_end_time: '2019-04-15'   # latest date included in features
    # label_start_time: '1975-01-02' # earliest date for which labels are avialable
    label_start_time: '2016-01-02' # earliest date for which labels are avialable
    label_end_time: '2019-04-16' # day AFTER last label date (all dates in any model are < this date)
    model_update_frequency: '1y' # how frequently to retrain models
    training_as_of_date_frequencies: '1y' # time between as of dates for same entity in train matrix
    test_as_of_date_frequencies: '1y' # time between as of dates for same entity in test matrix
    max_training_histories: ['6y'] # length of time included in a train matrix
    test_durations: ['7day'] # length of time included in a test matrix (0 days will give a single prediction immediately after training end)
    training_label_timespans: ['1y'] # time period across which outcomes are labeled in train matrices
    test_label_timespans: ['1y'] # time period across which outcomes are labeled in test matrices


# COHORT CONFIG
# Cohorts are configured by passing a query with placeholders for the 'as_of_date'.
#
# The 'query' key should have a query, parameterized with an '{as_of_date}', to select the entity_ids that should be included for a given date. The {as_of_date} will be replaced with each as_of_date that the experiment needs. 
# The returned 'entity_id' must be an integer.
#
# You may enter a 'name' for your configuration.
# This will be included in the metadata for each matrix and used to group models
# If you don't pass one, the string 'default' will be used.
#
cohort_config: # released in last 3 years
    query: |
        with sentence_info as (select distinct on (inmate_doc_number) * from cleaned.sentences where sentence_start < '{as_of_date}'::date order by inmate_doc_number, sentence_start desc), all_in as (select distinct inmate_doc_number from cleaned.sentences), numbered_entities as (select inmate_doc_number, ROW_NUMBER() over (order by inmate_doc_number) as inmate_num from all_in) select inmate_num::int as entity_id from sentence_info s left join numbered_entities n on s.inmate_doc_number = n.inmate_doc_number where sentence_end <@ daterange(('{as_of_date}'::date - interval '3year')::date, '{as_of_date}'::date);

    name: 'recently_released'


# LABEL GENERATION
# Labels are configured by passing a query with placeholders for the 'as_of_date' and 'label_timespan'.
#
# The query must return two columns: entity_id and outcome, based on a given as_of_date and label_timespan.
# The as_of_date and label_timespan must be represented by placeholders marked by curly brackets. The example below
# reproduces the inspection outcome boolean-or logic:
#
# In addition, you can configure what label is given to entities that are in the matrix
#   (see 'cohort_config' section) but that do not show up in this label query.
# By default, these will show up as missing/null.
# However, passing the key 'include_missing_labels_in_train_as' allows you to pick True or False.
#
# In addition to these configuration options, you can pass a name to apply to the label configuration
# that will be present in matrix metadata for each matrix created by this experiment,
# under the 'label_name' key. The default label_name is 'outcome'.
label_config:
    query: |
      select inmate_doc_number as entity_id, 1 as outcome from cleaned.sentences where sentence_start::date <@ daterange('{as_of_date}'::date, ('{as_of_date}'::date + interval '3year')::date) -- if they have a new start date after the beginning of the period, they recidivated (as only those inmates recently released are part of the cohort) group by entity_id;
    
    name: 'recidivated'
    
    include_missing_labels_in_train_as: False


feature_aggregations:

     -
        prefix: 'demographics'
        from_obj: |
          with all_in as (select distinct inmate_doc_number from cleaned.sentences), numbered_entities as (select inmate_doc_number, ROW_NUMBER() over (order by inmate_doc_number) as inmate_num from all_in) (select n.inmate_num::int as entity_id, s.entity_id as sentence_id, s.inmate_doc_number, inmate_commitment_prefix, sentence_start, sentence_end, inmate_race_code, inmate_gender_code, extract(year from s.inmate_birth_date) as birth_year, case when sentence_end - inmate_birth_date > 0 then floor(round(sentence_end - inmate_birth_date)/ 365)::int else null end as release_age, sentence_total_counts, new_period_of_incarceration_fl, new_period_of_supervision_flag, p_p_commitment_status_flag, minimum_sentence_length, maximum_sentence_length, parole_supervision_begin_date, parole_discharge_date, length_of_supervision from cleaned.sentences s join numbered_entities n on s.inmate_doc_number = n.inmate_doc_number) as inmate_sentences
        
        knowledge_date_column: 'sentence_end' # confirm with kit: should this be sentence start, as that is when we know someone has recidivated?

        aggregates_imputation:
            all:
              type: 'mean'

        aggregates:
          - # age in years
            quantity:
              age: extract(year from release_age('{collate_date}'::date, inmate_birth_date::date))
            metrics: ['max']

        categoricals_imputation:
            all:
              type: 'zero'
              
        categoricals:
            - # gender 
                column: inmate_gender_code
                choices: ['MALE', 'FEMALE']
                metrics:
                    - 'sum'
                    - 'avg'
                    - 'max'

            - # race 
                column: inmate_race_code
                choice_query: 'select distinct inmate_race_code from cleaned.sentences'
                metrics:
                    - 'sum'
                    - 'avg'
                    - 'max'
        intervals: ['1y', '3y', all']


        groups:
            - 'entity_id'


    
     -
        prefix: 'sentences'
        from_obj: |
          with all_in as (select distinct inmate_doc_number from cleaned.sentences), numbered_entities as (select inmate_doc_number, ROW_NUMBER() over (order by inmate_doc_number) as inmate_num from all_in) (select n.inmate_num::int as entity_id, s.entity_id as sentence_id, s.inmate_doc_number, inmate_commitment_prefix, sentence_start, sentence_end, inmate_race_code, inmate_gender_code, extract(year from s.inmate_birth_date) as birth_year, case when sentence_end - inmate_birth_date > 0 then floor(round(sentence_end - inmate_birth_date)/ 365)::int else null end as release_age, sentence_total_counts, new_period_of_incarceration_fl, new_period_of_supervision_flag, p_p_commitment_status_flag, minimum_sentence_length, maximum_sentence_length, parole_supervision_begin_date, parole_discharge_date, length_of_supervision from cleaned.sentences s join numbered_entities n on s.inmate_doc_number = n.inmate_doc_number) as inmate_sentences

        knowledge_date_column: 'sentence_end'

        aggregates_imputation:
            all:
              type: 'mean'

        aggregates:
          aggregates:
          - # number of sentences
            quantity:
              total: "*"
            metrics:
              - 'count'

          - # new_supervision
              quantity:
                new_supervision_bool: "case when new_period_of_supervision_flag = 'Y' then 1 else 0 end"
              metrics:
                  - 'avg'
                  - 'sum'

          - # new_incarceration
              quantity:
                new_incarceration_bool: "case when new_period_of_incarceration_fl = 'Y' then 1 else 0 end"
              metrics:
                  - 'avg'
                  - 'sum'

          - # parole_following
              quantity:
                parole_bool: "case when parole_supervision_begin_date is null then 0 else 1 end"
              metrics:
                  - 'avg'
                  - 'sum'

          - # days since last release (NOTE: all entities in cohort should have at least one prior release; adapted from joco small_master_config)
              quantity:
                days_since_release: ('{collate_date}'::date - sentence_start::date)
              metrics:
                - min
              imputation:
                  all:
                    type: 'error'

        intervals: ['1y', '3y', 'all']


        groups:
            - 'entity_id'


     - 
        prefix: 'offenses'
        from_obj: |
           with all_in as (select distinct inmate_doc_number from cleaned.sentences), numbered_entities as (select inmate_doc_number, ROW_NUMBER() over (order by inmate_doc_number) as inmate_num from all_in) (select distinct n.inmate_num::int as entity_id, s.entity_id as sentence_id, s.inmate_doc_number, s.inmate_commitment_prefix, sentence_start, sentence_end, o.primary_felony_misdemeanor_cd, o.serving_min_or_max_term_code, o.primary_offense_code, o.county_of_conviction_code, o.court_type_code, o.offense_qualifier_code, o.sentencing_penalty_class_code, o.prior_record_level_code from cleaned.sentences s left join numbered_entities n on s.inmate_doc_number = n.inmate_doc_number left join cleaned.offenses o on s.entity_id = o.entity_id) as inmate_offenses

        knowledge_date_column: 'sentence_end'

        aggregates_imputation:
            all:
              type: 'mean'

        aggregates:
          - # felony_offense
              quantity:
                felony_bool: "case when primary_felony_misdemeanor_cd = 'FELON' then 1 else 0 end"
              imputation:
                mean:
                    type: 'zero_noflag'
                sum:
                    type: 'zero_noflag'
              metrics:
                  - 'avg'
                  - 'sum'

          - # max_term
              quantity:
                max_term_bool: "case when serving_min_or_max_term_code = 'MAX.TERM:' then 1 else 0 end"
              imputation:
                mean:
                    type: 'zero_noflag'
                sum:
                    type: 'zero_noflag'
              metrics:
                  - 'avg'
                  - 'sum'
          - # number of different offenses 
            quantity:
              num_cities: DISTINCT primary_offense_code
            metrics:
                - count

        categoricals_imputation:
            all:
              type: 'mean'

        categoricals:
            - # offense location
                column: county_of_conviction_code
                choice_query: 'select distinct county_of_conviction_code from cleaned.offenses'
                metrics:
                    - 'sum'
                    - 'avg'
                    - 'max'

            - # type of offense 
                column: primary_offense_code
                choice_query: 'select distinct primary_offense_code from cleaned.offenses'
                metrics:
                    - 'sum'
                    - 'avg'
                    - 'max'

            - # offense qualifier
                column: offense_qualifier_code
                choice_query: 'select distinct offense_qualifier_code from cleaned.offenses'
                metrics:
                    - 'sum'
                    - 'avg'
                    - 'max'

            - # prior record level
                column: prior_record_level_code
                choice_query: 'select distinct prior_record_level_code from cleaned.offenses'
                metrics:
                    - 'sum'
                    - 'avg'
                    - 'max'
        
        intervals: ['1y', '3y', 'all']

        groups:
          - 'entity_id'
          - 'sentence_id'

     - 
        prefix: 'infractions'
        from_obj: |
           with all_in as (select distinct inmate_doc_number from cleaned.sentences), numbered_entities as (select inmate_doc_number, ROW_NUMBER() over (order by inmate_doc_number) as inmate_num from all_in) (select distinct n.inmate_num::int as entity_id, s.entity_id as sentence_id, s.inmate_doc_number, s.inmate_commitment_prefix, sentence_start, sentence_end, disciplinary_infraction_code, disci_segregation_time_days, inmate_plea_re_infraction, disciinfraction_verdict_code from cleaned.sentences s left join numbered_entities n on s.inmate_doc_number = n.inmate_doc_number left join cleaned.infractions i on s.entity_id = i.entity_id) as inmate_infractions

        knowledge_date_column: 'sentence_end'

        aggregates_imputation:
            all:
              type: 'mean'

        aggregates:

          - # number of infractions
            quantity:
              total: "*"
            metrics:
              - 'count'
              - 'max'

          - # number of different infractions 
            quantity:
              num_cities: DISTINCT disciplinary_infraction_code
            metrics:
                - count

          - # pct infractions pleaded guilty, any infractions pleaded guilty, total infractions pleaded guilty
              quantity:
                guilty_plea_bool: "case when inmate_plea_re_infraction = 'GUILTY' then 1 else 0 end"
              imputation:
                mean:
                    type: 'zero_noflag'
                sum:
                    type: 'zero_noflag'
              metrics:
                  - 'avg'
                  - 'max'
                  - sum

          - # pct infractions with guilty verdict, any infractions with guilty verdict, total infractions with guilty verdict
              quantity:
                guilty_verdict_bool: "case when disciinfraction_verdict_code = 'GUILTY' then 1 else 0 end"
              imputation:
                mean:
                    type: 'zero_noflag'
                sum:
                    type: 'zero_noflag'
              metrics:
                  - 'avg'
                  - 'max'
                  - 'sum'


        categoricals_imputation:
            all:
              type: 'mean'

        categoricals:
            - # type of disciplinary infraction
                column: disciplinary_infraction_code
                choice_query: 'select distinct disciplinary_infraction_code from cleaned.infractions'
                metrics:
                    - 'sum'
                    - 'avg'
                    - 'max'

        intervals: ['1y', '3y', 'all']

        groups:
          - 'entity_id'
          - 'sentence_id'


feature_group_strategies: ['all']

feature_group_definition:
    tables: ['demographics_aggregation_imputed', 'sentences_aggregation_imputed', 'offenses_aggregation_imputed', 'infractions_aggregation_imputed']

grid_config:
  'sklearn.tree.DecisionTreeClassifier':
    max_depth: [5]
    max_features: ['sqrt']
    min_samples_split: [2]
    criterion: ['gini']
  'triage.component.catwalk.estimators.classifiers.ScaledLogisticRegression':
     penalty: ['l1', 'l2']
     C: [0.00001, 0.001,  0.1]
     
scoring:
    sort_seed: 5
    testing_metric_groups:
        -
          metrics: [precision@, recall@]
          thresholds:
            percentiles: [1.0, 5.0, 10.0, 20.0]
            top_n: [100, 250, 500, 1000, 2500, 5000]

    training_metric_groups:
      -
        metrics: [accuracy]
      -
        metrics: [precision@, recall@]
        thresholds:
          percentiles: [1.0, 5.0, 10.0, 20.0]
          top_n: [100, 250, 500, 1000, 2500, 5000]


# INDIVIDUAL IMPORTANCES
individual_importance:
    methods: [] # empty list means don't calculate individual importances
    n_ranks: 10