config_version: 'v6'

model_comment: 'nc_recidivism: initial_test'

user_metadata:
    label_definition: 'recidivated'
    experiment_type: 'recidivism_prediction'
    description: |
      Baseline calculation
    purpose: 'baseline'
    org: 'DSaPP'
    team: 'Aequitas for Triage'
    author: 'Loren Hinkson'
    etl_date: '2019-05-29'

model_group_keys:
  - 'class_path'
  - 'parameters'
  - 'feature_names'
  - 'feature_groups'
  - 'cohort_name'
  - 'state'
  - 'label_name'
  - 'label_timespan'
  - 'training_as_of_date_frequency'
  - 'max_training_history'
  - 'label_definition'
  - 'experiment_type'
  - 'org'
  - 'team'
  - 'author'
  - 'purpose'
  - 'etl_date'
  
 
# TIME SPLITTING
# The time window to look at, and how to divide the window into
# train/test splits
temporal_config:
    feature_start_time: '1975-01-01' # earliest date included in features
    feature_end_time: '2019-04-15'   # latest date included in features
    label_start_time: '1950-03-30' # earliest date for which labels are avialable
    label_end_time: '2019-04-16' # day AFTER last label date (all dates in any model are < this date)
    model_update_frequency: '1year' # how frequently to retrain models
    training_as_of_date_frequencies: '1year' # time between as of dates for same entity in train matrix
    test_as_of_date_frequencies: '1year' # time between as of dates for same entity in test matrix
    max_training_histories: ['6y'] # length of time included in a train matrix
    test_durations: ['7day'] # length of time included in a test matrix (0 days will give a single prediction immediately after training end)
    training_label_timespans: ['3y'] # time period across which outcomes are labeled in train matrices
    test_label_timespans: ['3y'] # time period across which outcomes are labeled in test matrices


# COHORT CONFIG
# Cohorts are configured by passing a query with placeholders for the 'as_of_date'.
#
# The 'query' key should have a query, parameterized with an '{as_of_date}', to select the entity_ids that should be included for a given date. The {as_of_date} will be replaced with each as_of_date that the experiment needs. The returned 'entity_id' must be an integer.
#
# You may enter a 'name' for your configuration.
# This will be included in the metadata for each matrix and used to group models
# If you don't pass one, the string 'default' will be used.
#
cohort_config:
    query: |
        with start_sentence as (select distinct on (inmate_doc_number) *
        from cleaned.sentences 
        where sentence_start < '{as_of_date}'::date
        order by inmate_doc_number, sentence_start desc)
        select inmate_doc_number as entity_id
        from start_sentence
        where sentence_end <@ daterange(('{as_of_date}'::date - interval '3year')::date, '{as_of_date}'::date);        
    name: 'recently_released'


# LABEL GENERATION
# Labels are configured by passing a query with placeholders for the 'as_of_date' and 'label_timespan'.
#
# The query must return two columns: entity_id and outcome, based on a given as_of_date and label_timespan.
# The as_of_date and label_timespan must be represented by placeholders marked by curly brackets. The example below
# reproduces the inspection outcome boolean-or logic:
#
# In addition, you can configure what label is given to entities that are in the matrix
#   (see 'cohort_config' section) but that do not show up in this label query.
# By default, these will show up as missing/null.
# However, passing the key 'include_missing_labels_in_train_as' allows you to pick True or False.
#
# In addition to these configuration options, you can pass a name to apply to the label configuration
# that will be present in matrix metadata for each matrix created by this experiment,
# under the 'label_name' key. The default label_name is 'outcome'.
label_config:
    query: |
         select inmate_doc_number as entity_id, 1 as outcome 
         from cleaned.nc_recidivism
         where sentence_start::date <@ daterange('{as_of_date}'::date, ('{as_of_date}'::date + interval '3year')::date)
         group by entity_id;
    name: 'recidivated'
    include_missing_labels_in_train_as: False


feature_aggregations:
    -
        prefix: 'nc_recid'
        from_obj: 'cleaned.sentences'
        # The date column to use for specifying which records to include
        # in temporal features. It is important that the column used specifies
        # the date at which the event is known about, which may be different
        # from the date the event happened.
        knowledge_date_column: 'sentence_end'

        # top-level imputation rules that will apply to all aggregates functions
        # can also specify categoricals_imputation or array_categoricals_imputation
        #
        # You must specified at least one of the top-level or feature-level imputation
        # to cover ever feature being defined.
        aggregates_imputation:
            count:
                type: 'zero_noflag'


        # aggregates and categoricals define the actual features created. So
        # at least one is required
        #
        # Aggregates of numerical columns. Each quantity is a number of some
        # sort, and the list of metrics are applied to each quantity
        aggregates:
            -
                quantity: minimum_sentence_length::int
                # Imputation rules specified at the level of specific features
                # will take precedence over the higer-level rules specified
                # above. Note that the 'count' and 'sum' metrics will be
                # imputed differently here.
                imputation:
                    mean:
                        type: 'zero_noflag'
                    sum:
                        type: 'zero_noflag'
                metrics:
                    - 'mean'
                    - 'sum'
            -
                quantity: maximum_sentence_length::int
                # Imputation rules specified at the level of specific features
                # will take precedence over the higer-level rules specified
                # above. Note that the 'count' and 'sum' metrics will be
                # imputed differently here.
                imputation:
                    mean:
                       type: 'zero_noflag'
                    sum:
                        type: 'zero_noflag'
                metrics:
                    - 'mean'
                    - 'sum'
            - 
                quantity: previous_commitments::int
                # Imputation rules specified at the level of specific features
                # will take precedence over the higer-level rules specified
                # above. Note that the 'count' and 'sum' metrics will be
                # imputed differently here.
                imputation:
                    mean:
                       type: 'zero_noflag'
                    sum:
                        type: 'zero_noflag'
                metrics:
                    - 'mean'
                    - 'sum'
            -
                # since we're specifying `aggregates_imputation` above,
                # a feature-specific imputation rule can be omitted
                quantity: parole_days::int
                imputation:
                    all:
                       type: 'zero_noflag'
                metrics:
                    - 'mean'
                    - 'sum'
            -
                # since we're specifying `aggregates_imputation` above,
                # a feature-specific imputation rule can be omitted
                quantity: age_at_release::int
                imputation:
                    all:
                       type: 'zero_noflag'
                metrics:
                    - 'mean'
                    - 'sum'
        # Categorical features. The column given can be of any type, but the
        # choices must comparable to that type for equality within SQL
        # The result will be one feature for each choice/metric combination
        categoricals:
            -
                column: 'inmate_commitment_prefix'
                # note that we haven't specified a top level `categoricals_imputation`
                # set of rules, so we have to include feature-specific imputation
                # rules for both of our categoricals here.
                imputation:
                    sum:
                        type: 'null_category'
                    mean:
                        type: 'mean'
                metrics:
                    - 'sum'
                    - 'mean'
            -
                column: 'inmate_race_code'
                # as with the top-level imputation rules, `all` can be used
                # for the feature-level rules to specify the same type of
                # imputation for all aggregation functions
                imputation:
                    all:
                        type: 'null_category'
                choice_query: 'select distinct shape from cool_stuff'
                metrics:
                    - 'sum'
                    - 'mean'
            - 
                column: 'inmate_gender_code'
                # as with the top-level imputation rules, `all` can be used
                # for the feature-level rules to specify the same type of
                # imputation for all aggregation functions
                imputation:
                    all:
                        type: 'null_category'
                choices:
                    - 'MALE'
                    - 'FEMALE'
                metrics:
                    - 'sum'
                    - 'mean'
            - 
                column: 'new_period_of_incarceration_fl'
                # as with the top-level imputation rules, `all` can be used
                # for the feature-level rules to specify the same type of
                # imputation for all aggregation functions
                imputation:
                    all:
                        type: 'null_category'
                metrics:
                    - 'sum'
                    - 'mean'
        # The time intervals over which to aggregate features
        intervals:
            - '1 year'
        # A list of different columns to separately group by
        groups:
            - 'entity_id'


feature_group_strategies: ['all']


feature_group_definition:
   prefix:
     - 'nc_recidivism'


grid_config:
  'triage.component.catwalk.estimators.classifiers.ScaledLogisticRegression':
     penalty: ['l1', 'l2']
     C: [0.00001, 0.001,  0.1]
     
scoring:
    testing_metric_groups:
        -
          metrics: [precision@, recall@]
          thresholds:
            percentiles: [1.0, 2.0, 3.0, 4.0, 5.0, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100]
            top_n: [1, 5, 10, 25, 50, 100, 250, 500, 1000]

    training_metric_groups:
      -
        metrics: [accuracy]
      -
        metrics: [precision@, recall@]
        thresholds:
          percentiles: [1.0, 2.0, 3.0, 4.0, 5.0, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100]
          top_n: [1, 5, 10, 25, 50, 100, 250, 500, 1000]